<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ë§ˆìŠ¤í„°ê¸‰ AI ì²´ìŠ¤ - v12</title>
    <style>
        body { display: flex; flex-direction: column; align-items: center; font-family: -apple-system, sans-serif; background-color: #fcf9f2; margin: 0; padding: 10px; touch-action: manipulation; }
        .captured-area { width: 95vw; max-width: 500px; height: 35px; display: flex; align-items: center; gap: 4px; font-size: 22px; padding: 5px 0; border-bottom: 1px solid #ddd; margin-bottom: 5px; }
        #board { display: grid; grid-template-columns: repeat(8, 1fr); grid-template-rows: repeat(8, 1fr); width: 95vw; max-width: 500px; height: 95vw; max-height: 500px; border: 5px solid #3d2b1f; box-shadow: 0 10px 25px rgba(0,0,0,0.2); }
        .square { display: flex; justify-content: center; align-items: center; font-size: calc(95vw / 10); cursor: pointer; user-select: none; -webkit-tap-highlight-color: transparent; }
        @media (min-width: 500px) { .square { font-size: 50px; } }
        .light { background-color: #fceecf; } .dark { background-color: #b58863; }
        .selected { background-color: #7b9a58 !important; }
        .pending { background-color: #e5c158 !important; }

        /* í”¼ìŠ¤ ë””ìì¸: í°ìƒ‰ì€ ì•ˆì„ íšŒìƒ‰ìœ¼ë¡œ ì±„ì›€ */
        .black-piece { color: #000000; font-weight: bold; }
        .white-piece { color: #d3d3d3; text-shadow: 1px 1px 1px #000, -1px -1px 1px #000, 1px -1px 1px #000, -1px 1px 1px #000; font-weight: bold; }

        #controls, #difficulty-selector, #undo-area, #castle-area { margin-top: 10px; width: 95vw; max-width: 500px; display: flex; gap: 8px; }
        button { flex: 1; padding: 12px 0; font-size: 14px; font-weight: bold; border: none; border-radius: 8px; cursor: pointer; color: white; }
        .diff-btn { background-color: #ddd; color: #333; }
        .diff-btn.active { background-color: #3d2b1f; color: white; }
        #btn-confirm { background-color: #4CAF50; display: none; }
        #btn-cancel { background-color: #f44336; display: none; }
        #btn-undo { background-color: #607d8b; } 
        .castle-btn { background-color: #2196F3; display: none; } 
        #status { margin: 5px 0; font-size: 16px; font-weight: bold; color: #3d2b1f; min-height: 20px; }
    </style>
</head>
<body>
    <div id="status">ìƒëŒ€í•  ë‚œì´ë„ë¥¼ ì„ íƒí•˜ì„¸ìš”</div>
    <div id="difficulty-selector">
        <button class="diff-btn" onclick="setDiff(2, this)">ì¤‘ê°„ ìˆ˜ì¤€</button>
        <button class="diff-btn active" onclick="setDiff(4, this)">êµ‰ì¥íˆ ë†’ìŒ (Depth 4)</button>
    </div>
    <div id="black-captured" class="captured-area"></div>
    <div id="board"></div>
    <div id="white-captured" class="captured-area"></div>
    <div id="castle-area">
        <button id="btn-castle-king" class="castle-btn" onclick="doCastle('king')">í‚¹ì‚¬ì´ë“œ ìºìŠ¬ë§ ğŸ°</button>
        <button id="btn-castle-queen" class="castle-btn" onclick="doCastle('queen')">í€¸ì‚¬ì´ë“œ ìºìŠ¬ë§ ğŸ°</button>
    </div>
    <div id="undo-area"><button id="btn-undo" onclick="undoMove()">í•œ ìˆ˜ ë˜ëŒë¦¬ê¸° (Undo)</button></div>
    <div id="controls">
        <button id="btn-cancel" onclick="cancelMove()">ì·¨ì†Œ</button>
        <button id="btn-confirm" onclick="confirmMove()">ì´ë™ í™•ì •</button>
    </div>

    <script>
        window.onload = function() {
            const boardElement = document.getElementById('board');
            const pieces = { r:'â™œ', n:'â™', b:'â™', q:'â™›', k:'â™š', p:'â™Ÿ', R:'â™œ', N:'â™', B:'â™', Q:'â™›', K:'â™š', P:'â™Ÿ' };
            const pieceValues = { p: 100, n: 320, b: 330, r: 500, q: 900, k: 20000 };
            
            // Piece-Square Tables (AIì˜ ì „ëµì  ìœ„ì¹˜ íŒë‹¨ ê¸°ì¤€)
            const pst = {
                p: [ [0,0,0,0,0,0,0,0], [50,50,50,50,50,50,50,50], [10,10,20,30,30,20,10,10], [5,5,10,25,25,10,5,5], [0,0,0,20,20,0,0,0], [5,-5,-10,0,0,-10,-5,5], [5,10,10,-20,-20,10,10,5], [0,0,0,0,0,0,0,0] ],
                n: [ [-50,-40,-30,-30,-30,-30,-40,-50], [-40,-20,0,0,0,0,-20,-40], [-30,0,10,15,15,10,0,-30], [-30,5,15,20,20,15,5,-30], [-30,0,15,20,20,15,0,-30], [-30,5,10,15,15,10,5,-30], [-40,-20,0,5,5,0,-20,-40], [-50,-40,-30,-30,-30,-30,-40,-50] ]
            };

            let boardState = [
                ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
                ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
                ['', '', '', '', '', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
                ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
            ];

            let movedStatus = { whiteKing: false, whiteRookLeft: false, whiteRookRight: false, blackKing: false, blackRookLeft: false, blackRookRight: false };
            let turn = 'White';
            let searchDepth = 4;
            let selected = null;
            let pendingMove = null;
            let capturedByWhite = [];
            let capturedByBlack = [];
            let gameHistory = [];

            const isWhite = (p) => p && p === p.toUpperCase();
            const isBlack = (p) => p && p === p.toLowerCase();

            function renderBoard() {
                boardElement.innerHTML = '';
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const square = document.createElement('div');
                        square.className = `square ${(r + c) % 2 === 0 ? 'light' : 'dark'}`;
                        if (selected && selected.r === r && selected.c === c) square.classList.add('selected');
                        if (pendingMove && pendingMove.toR === r && pendingMove.toC === c) square.classList.add('pending');
                        const piece = boardState[r][c];
                        if (piece) {
                            square.textContent = pieces[piece];
                            square.classList.add(isWhite(piece) ? 'white-piece' : 'black-piece');
                        }
                        square.onclick = () => handleSquareClick(r, c);
                        boardElement.appendChild(square);
                    }
                }
                document.getElementById('white-captured').innerHTML = capturedByWhite.map(p => pieces[p]).join(' ');
                document.getElementById('black-captured').innerHTML = capturedByBlack.map(p => pieces[p]).join(' ');
                updateCastleButtons();
            }

            function updateCastleButtons() {
                const kBtn = document.getElementById('btn-castle-king'), qBtn = document.getElementById('btn-castle-queen');
                kBtn.style.display = qBtn.style.display = 'none';
                if (selected && boardState[selected.r][selected.c] === 'K' && !pendingMove) {
                    if (canCastle(selected.r, selected.c, 7, 6)) kBtn.style.display = 'block';
                    if (canCastle(selected.r, selected.c, 7, 2)) qBtn.style.display = 'block';
                }
            }

            // í‰ê°€ í•¨ìˆ˜ (PST ì ìš©ìœ¼ë¡œ ì „ëµì  íŒë‹¨ ê°•í™”)
            function evaluateBoard(state) {
                let total = 0;
                for (let r=0; r<8; r++) for (let c=0; c<8; c++) {
                    let p = state[r][c]; if (!p) continue;
                    let type = p.toLowerCase();
                    let val = pieceValues[type];
                    // PST ê°€ì‚°ì  (í‘/ë°± ëŒ€ì¹­ ì ìš©)
                    if (pst[type]) {
                        val += isBlack(p) ? pst[type][r][c] : pst[type][7-r][c];
                    }
                    total += isWhite(p) ? -val : val;
                }
                return total;
            }

            // ì•ŒíŒŒ-ë² íƒ€ ë¯¸ë‹ˆë§¥ìŠ¤ + ìˆ˜ ì •ë ¬
            function minimax(state, depth, alpha, beta, isMax) {
                if (depth === 0) return evaluateBoard(state);
                let moves = getAllMoves(state, isMax ? 'Black' : 'White');
                
                // ìˆ˜ ì •ë ¬ (ì¡ê¸°ê°€ ê°€ëŠ¥í•œ ìˆ˜ë¥¼ ìš°ì„  íƒìƒ‰í•˜ì—¬ íš¨ìœ¨ ê·¹ëŒ€í™”)
                moves.sort((a, b) => {
                    let scoreA = state[a.tr][a.tc] ? pieceValues[state[a.tr][a.tc].toLowerCase()] : 0;
                    let scoreB = state[b.tr][b.tc] ? pieceValues[state[b.tr][b.tc].toLowerCase()] : 0;
                    return scoreB - scoreA;
                });

                if (isMax) {
                    let v = -Infinity;
                    for (let m of moves) {
                        v = Math.max(v, minimax(sim(state, m), depth-1, alpha, beta, false));
                        alpha = Math.max(alpha, v); if (beta <= alpha) break;
                    }
                    return v;
                } else {
                    let v = Infinity;
                    for (let m of moves) {
                        v = Math.min(v, minimax(sim(state, m), depth-1, alpha, beta, true));
                        beta = Math.min(beta, v); if (beta <= alpha) break;
                    }
                    return v;
                }
            }

            function makeAIMove() {
                document.getElementById('status').innerText = "AIê°€ ìµœì ì˜ ìˆ˜ë¥¼ ì°¾ëŠ” ì¤‘ (Depth " + searchDepth + ")...";
                setTimeout(() => {
                    let moves = getAllMoves(boardState, 'Black');
                    let bestM = null, bestV = -Infinity;
                    for (let m of moves) {
                        let v = minimax(sim(boardState, m), searchDepth-1, -Infinity, Infinity, false);
                        if (v > bestV) { bestV = v; bestM = m; }
                    }
                    if (bestM) {
                        if (boardState[bestM.tr][bestM.tc]) capturedByBlack.push(boardState[bestM.tr][bestM.tc]);
                        boardState[bestM.tr][bestM.tc] = boardState[bestM.fr][bestM.fc];
                        boardState[bestM.fr][bestM.fc] = '';
                        turn = 'White'; renderBoard();
                        document.getElementById('status').innerText = "ë‹¹ì‹ ì˜ ì°¨ë¡€ (ë°±)";
                    }
                }, 100);
            }

            // ë‚˜ë¨¸ì§€ ê¸°ëŠ¥ ë¡œì§ (v11ê³¼ ë™ì¼ ë° ë³´ì™„)
            window.doCastle = (s) => { if(!selected) return; handleSquareClick(7, s==='king'?6:2); };
            window.undoMove = () => { if(gameHistory.length > 0) { let l = JSON.parse(gameHistory.pop()); boardState=l.boardState; movedStatus=l.movedStatus; capturedByWhite=l.capturedByWhite; capturedByBlack=l.capturedByBlack; turn='White'; pendingMove=null; selected=null; renderBoard(); document.getElementById('status').innerText="ë¬´ë¥´ê¸° ì™„ë£Œ"; } };
            window.confirmMove = () => { saveHistory(); if(pendingMove.captured) capturedByWhite.push(pendingMove.captured); updateMovedStatus(pendingMove.fromR, pendingMove.fromC, pendingMove.piece); pendingMove=null; turn='Black'; document.getElementById('btn-confirm').style.display='none'; document.getElementById('btn-cancel').style.display='none'; renderBoard(); makeAIMove(); };
            window.cancelMove = () => { if(pendingMove.isCastling) { if(pendingMove.toC > pendingMove.fromC) { boardState[pendingMove.fromR][7]=boardState[pendingMove.fromR][pendingMove.toC-1]; boardState[pendingMove.fromR][pendingMove.toC-1]=''; } else { boardState[pendingMove.fromR][0]=boardState[pendingMove.fromR][pendingMove.toC+1]; boardState[pendingMove.fromR][pendingMove.toC+1]=''; } } boardState[pendingMove.fromR][pendingMove.fromC]=pendingMove.piece; boardState[pendingMove.toR][pendingMove.toC]=pendingMove.captured; pendingMove=null; renderBoard(); document.getElementById('btn-confirm').style.display='none'; document.getElementById('btn-cancel').style.display='none'; };
            function saveHistory() { gameHistory.push(JSON.stringify({ boardState, movedStatus, capturedByWhite, capturedByBlack })); }
            function handleSquareClick(r, c) { if(turn==='Black'||pendingMove) return; const p=boardState[r][c]; if(selected) { if(selected.r===r && selected.c===c) { selected=null; renderBoard(); } else if(isWhite(p)) { selected={r,c}; renderBoard(); } else if(isValidMoveLogic(boardState, selected.r, selected.c, r, c) || canCastle(selected.r, selected.c, r, c)) { pendingMove={ fromR:selected.r, fromC:selected.c, toR:r, toC:c, piece:boardState[selected.r][selected.c], captured:boardState[r][c], isCastling:canCastle(selected.r, selected.c, r, c) }; boardState[r][c]=pendingMove.piece; boardState[selected.r][selected.c]=''; if(pendingMove.isCastling) { if(c>selected.c) { boardState[r][c-1]=boardState[r][7]; boardState[r][7]=''; } else { boardState[r][c+1]=boardState[r][0]; boardState[r][0]=''; } } selected=null; renderBoard(); document.getElementById('btn-confirm').style.display='block'; document.getElementById('btn-cancel').style.display='block'; } } else if(isWhite(p)) { selected={r,c}; renderBoard(); } }
            function canCastle(fr, fc, tr, tc) { const p=boardState[fr][fc]; if(p!=='K' || Math.abs(tc-fc)!==2 || fr!==tr || movedStatus.whiteKing) return false; if(tc>fc) { if(movedStatus.whiteRookRight || boardState[fr][fc+1]!=='' || boardState[fr][fc+2]!=='') return false; } else { if(movedStatus.whiteRookLeft || boardState[fr][fc-1]!=='' || boardState[fr][fc-2]!=='' || boardState[fr][fc-3]!=='') return false; } return true; }
            function updateMovedStatus(r, c, p) { if(p==='K') movedStatus.whiteKing=true; if(p==='k') movedStatus.blackKing=true; if(p==='R') { if(c===0) movedStatus.whiteRookLeft=true; if(c===7) movedStatus.whiteRookRight=true; } }
            function getAllMoves(s, color) { let m=[]; for(let r=0; r<8; r++) for(let c=0; c<8; c++) if((color==='White' && isWhite(s[r][c])) || (color==='Black' && isBlack(s[r][c]))) for(let tr=0; tr<8; tr++) for(let tc=0; tc<8; tc++) if(isValidMoveLogic(s, r, c, tr, tc)) m.push({fr:r, fc:c, tr:tr, tc:tc}); return m; }
            function sim(s, m) { let n=s.map(r=>[...r]); n[m.tr][m.tc]=n[m.fr][m.fc]; n[m.fr][m.fc]=''; return n; }
            function isValidMoveLogic(s, fr, fc, tr, tc) { const p=s[fr][fc]; if(!p) return false; const target=s[tr][tc]; const dr=tr-fr, dc=tc-fc, absDr=Math.abs(dr), absDc=Math.abs(dc); if(target && ((isWhite(p) && isWhite(target)) || (isBlack(p) && isBlack(target)))) return false; const path=() => { let sR=dr===0?0:dr/absDr, sC=dc===0?0:dc/absDc, cR=fr+sR, cC=fc+sC; while(cR!==tr||cC!==tc) { if(s[cR][cC]!=='') return false; cR+=sR; cC+=sC; } return true; }; const t=p.toLowerCase(); if(t==='p') { const dir=isWhite(p)?-1:1; if(dc===0 && dr===dir && target==='') return true; if(dc===0 && dr===dir*2 && (fr===6||fr===1) && target==='' && s[fr+dir][fc]==='') return true; if(absDc===1 && dr===dir && target!=='') return true; return false; } if(t==='r') return (dr===0||dc===0) && path(); if(t==='b') return absDr===absDc && path(); if(t==='q') return (dr===0||dc===0||absDr===absDc) && path(); if(t==='k') return absDr<=1 && absDc<=1; if(t==='n') return (absDr===2 && absDc===1) || (absDr===1 && absDc===2); return false; }
            window.setDiff = (d, b) => { searchDepth=d; document.querySelectorAll('.diff-btn').forEach(btn=>btn.classList.remove('active')); b.classList.add('active'); };
            renderBoard();
        };
    </script>
</body>
</html>
