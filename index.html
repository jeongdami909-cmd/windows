// AI 엔진 (V25: 위치 가중치 및 정적 탐색 도입)
const workerCode = `
    self.onmessage = function(e) {
        const { boardState, depth } = e.data;
        
        // 기물별 가치 설정
        const pieceValues = { p: 100, n: 320, b: 330, r: 500, q: 900, k: 20000 };
        
        // 위치 가중치 테이블 (PST) - 흑색 기물 기준 (백색은 반전)
        const pst = {
            p: [0,0,0,0,0,0,0,0, 50,50,50,50,50,50,50,50, 10,10,20,30,30,20,10,10, 5,5,10,25,25,10,5,5, 0,0,0,20,20,0,0,0, 5,-5,-10,0,0,-10,-5,5, 5,10,10,-20,-20,10,10,5, 0,0,0,0,0,0,0,0],
            n: [-50,-40,-30,-30,-30,-30,-40,-50,-40,-20,0,0,0,0,-20,-40,-30,0,10,15,15,10,0,-30,-30,5,15,20,20,15,5,-30,-30,0,15,20,20,15,0,-30,-30,5,10,15,15,10,5,-30,-40,-20,0,5,5,0,-20,-40,-50,-40,-30,-30,-30,-30,-40,-50],
            b: [-20,-10,-10,-10,-10,-10,-10,-20,-10,0,0,0,0,0,0,-10,-10,0,5,10,10,5,0,-10,-10,5,5,10,10,5,5,-10,-10,0,10,10,10,10,0,-10,-10,10,10,10,10,10,10,-10,-10,5,0,0,0,0,5,-10,-20,-10,-10,-10,-10,-10,-10,-20],
            r: [0,0,0,0,0,0,0,0, 5,10,10,10,10,10,10,5, -5,0,0,0,0,0,0,-5, -5,0,0,0,0,0,0,-5, -5,0,0,0,0,0,0,-5, -5,0,0,0,0,0,0,-5, -5,0,0,5,5,0,0,-5, 0,0,0,5,5,0,0,0],
            q: [-20,-10,-10,-5,-5,-10,-10,-20,-10,0,0,0,0,0,0,-10,-10,0,5,5,5,5,0,-10, -5,0,5,5,5,5,0,-5, 0,0,5,5,5,5,0,-5,-10,5,5,5,5,5,0,-10,-10,0,5,0,0,0,0,-10,-20,-10,-10,-5,-5,-10,-10,-20],
            k: [-30,-40,-40,-50,-50,-40,-40,-30,-30,-40,-40,-50,-50,-40,-40,-30,-30,-40,-40,-50,-50,-40,-40,-30,-30,-40,-40,-50,-50,-40,-40,-30,-20,-30,-30,-40,-40,-30,-30,-20,-10,-20,-20,-20,-20,-20,-20,-10, 20,20,0,0,0,0,20,20, 20,30,10,0,0,10,30,20]
        };

        const isWhite = (p) => !!p && p === p.toUpperCase();
        const isBlack = (p) => !!p && p === p.toLowerCase();

        function evaluate(state) {
            let score = 0;
            for(let r=0; r<8; r++) {
                for(let c=0; c<8; c++) {
                    let p = state[r][c];
                    if(!p) continue;
                    let type = p.toLowerCase();
                    let val = pieceValues[type];
                    let tableIdx = r * 8 + c;
                    
                    // 백색 기물은 테이블을 뒤집어서 적용
                    if(isWhite(p)) {
                        let whiteIdx = (7-r) * 8 + c;
                        score -= (val + pst[type][whiteIdx]);
                    } else {
                        score += (val + pst[type][tableIdx]);
                    }
                }
            }
            return score;
        }

        // 정적 탐색 (캡처가 끝날 때까지 조금 더 깊게 봄)
        function quiesce(state, alpha, beta, isMax) {
            let stand_pat = evaluate(state);
            if(isMax) {
                if(stand_pat >= beta) return beta;
                if(alpha < stand_pat) alpha = stand_pat;
            } else {
                if(stand_pat <= alpha) return alpha;
                if(beta > stand_pat) beta = stand_pat;
            }

            let moves = getAllMoves(state, isMax ? 'Black' : 'White').filter(m => state[m.tr][m.tc] !== '');
            if(moves.length === 0) return stand_pat;

            for(let m of moves) {
                let score = quiesce(sim(state, m), alpha, beta, !isMax);
                if(isMax) {
                    if(score >= beta) return beta;
                    if(score > alpha) alpha = score;
                } else {
                    if(score <= alpha) return alpha;
                    if(score < beta) beta = score;
                }
            }
            return isMax ? alpha : beta;
        }

        function minimax(state, d, alpha, beta, isMax) {
            if(d === 0) return quiesce(state, alpha, beta, isMax);
            
            let moves = getAllMoves(state, isMax ? 'Black' : 'White');
            if(moves.length === 0) return evaluate(state);

            // 가치 높은 기물 잡기 순으로 정렬 (MVV-LVA)
            moves.sort((a,b) => (state[b.tr][b.tc]?pieceValues[state[b.tr][b.tc].toLowerCase()]:0) - (state[a.tr][a.tc]?pieceValues[state[a.tr][a.tc].toLowerCase()]:0));

            if(isMax) {
                let v = -Infinity;
                for(let m of moves) {
                    v = Math.max(v, minimax(sim(state, m), d-1, alpha, beta, false));
                    alpha = Math.max(alpha, v);
                    if(beta <= alpha) break;
                }
                return v;
            } else {
                let v = Infinity;
                for(let m of moves) {
                    v = Math.min(v, minimax(sim(state, m), d-1, alpha, beta, true));
                    beta = Math.min(beta, v);
                    if(beta <= alpha) break;
                }
                return v;
            }
        }

        function getAllMoves(s, color) {
            let m = [];
            for(let r=0; r<8; r++) {
                for(let c=0; c<8; c++) {
                    const p = s[r][c];
                    if(!p) continue;
                    if((color==='White' && isWhite(p)) || (color==='Black' && isBlack(p))) {
                        for(let tr=0; tr<8; tr++) {
                            for(let tc=0; tc<8; tc++) {
                                if(isValid(s, r, c, tr, tc)) m.push({fr:r, fc:c, tr:tr, tc:tc});
                            }
                        }
                    }
                }
            }
            return m;
        }

        function isValid(s, fr, fc, tr, tc) {
            if(fr === tr && fc === tc) return false;
            const p = s[fr][fc];
            if(!p) return false;
            const target = s[tr][tc];
            if(target && ((isWhite(p) && isWhite(target)) || (isBlack(p) && isBlack(target)))) return false;
            
            const dr = tr-fr, dc = tc-fc;
            const path = () => {
                let sR = dr === 0 ? 0 : dr/Math.abs(dr);
                let sC = dc === 0 ? 0 : dc/Math.abs(dc);
                let cR = fr + sR, cC = fc + sC;
                while(cR !== tr || cC !== tc) {
                    if(s[cR][cC] !== '') return false;
                    cR += sR; cC += sC;
                }
                return true;
            };

            const t = p.toLowerCase();
            if(t==='p') {
                const dir = isWhite(p) ? -1 : 1;
                if(dc === 0 && dr === dir && target === '') return true;
                if(dc === 0 && dr === dir*2 && (fr === 6 || fr === 1) && target === '' && s[fr+dir][fc] === '') return true;
                if(Math.abs(dc) === 1 && dr === dir && target !== '') return true;
                return false;
            }
            if(t==='r') return (dr===0 || dc===0) && path();
            if(t==='b') return Math.abs(dr)===Math.abs(dc) && path();
            if(t==='q') return (dr===0 || dc===0 || Math.abs(dr)===Math.abs(dc)) && path();
            if(t==='k') return Math.abs(dr)<=1 && Math.abs(dc)<=1;
            if(t==='n') return (Math.abs(dr)===2 && Math.abs(dc)===1) || (Math.abs(dr)===1 && Math.abs(dc)===2);
            return false;
        }

        function sim(s, m) {
            let n = s.map(r => [...r]);
            n[m.tr][m.tc] = n[m.fr][m.fc];
            n[m.fr][m.fc] = '';
            return n;
        }

        let moves = getAllMoves(boardState, 'Black');
        // AI 수 선택 시에도 정렬 적용
        moves.sort((a,b) => (boardState[b.tr][b.tc]?1:0) - (boardState[a.tr][a.tc]?1:0));

        let bestM = null, bestV = -Infinity;
        for (let m of moves) {
            let v = minimax(sim(boardState, m), depth-1, -Infinity, Infinity, false);
            if (v > bestV) { bestV = v; bestM = m; }
        }
        self.postMessage(bestM);
    };
`;
